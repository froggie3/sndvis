# メモリリーク診断ガイド

## Chrome DevTools Memory Profilerの使用方法

### 手順1: ヒープスナップショットの取得

1. アプリを起動
2. Chrome DevToolsを開く（F12）
3. "Memory"タブを選択
4. "Heap snapshot"を選択
5. 以下の手順でスナップショットを3回取得：
   - **スナップショット1**: アプリ起動直後（ベースライン）
   - **スナップショット2**: 30秒後
   - **スナップショット3**: 60秒後

### 手順2: スナップショットの比較

1. スナップショット3を選択
2. 上部のドロップダウンを "Summary" から "Comparison" に変更
3. "compared to Snapshot 1" を選択
4. "# Delta" でソート（増加数の多い順）

### 手順3: 犯人の特定

増加しているオブジェクトの種類を確認：
- `Array` が大量に増えている → 配列のリーク
- `Object` が大量に増えている → オブジェクトのリーク  
- `Float32Array` が増えている → オーディオバッファのリーク
- `system / Context` が増えている → p5.js内部のリーク

---

## 手順2: Performance Profilerでメモリ推移を記録

1. "Performance"タブを選択
2. "Memory"チェックボックスをONにする
3. 録画ボタン（●）をクリック
4. 1分間待つ
5. 停止ボタン（■）をクリック
6. メモリグラフを確認：
   - **正常**: 鋸歯状（増加→GCで減少を繰り返す）
   - **リーク**: 右肩上がりの直線（減少しない）

---

## 手順3: Allocation Timeline

1. "Memory"タブ → "Allocation instrumentation on timeline"を選択
2. "Start"をクリック
3. 30秒待つ
4. "Stop"をクリック
5. タイムライン上の青いバーをクリック
6. どのコードパスがメモリを割り当てているかを確認

---

## よくある犯人

### p5.jsの場合
- `p.fill()`, `p.stroke()` のColorオブジェクトの蓄積
- `p.push()` / `p.pop()` の不均衡
- Graphics bufferの未解放

### カスタムコードの場合
- イベントリスナーの未削除
- タイマー/setIntervalの未クリア
- クロージャーによる参照の保持
- 配列へのpushし続け
